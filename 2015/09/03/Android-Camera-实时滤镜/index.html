
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Android Camera 实时滤镜 | Ching.Soulwolf</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Soulwolf">
    
    <meta name="description" content="版权声明：转载自http://blog.csdn.net/wyhuan1030/article/details/45094715
一、Android系统将内置滤镜功能滤镜功能有二十余种不同效果，不逊色于极受欢迎的智能手机应用Instagram所产生的效果。

1、颜色矩阵 ColorMatrix
a">
    
    
    
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="devsoulwolf" />
    <meta name="twitter:title" content="Android Camera 实时滤镜 | Ching.Soulwolf" />
      
    
    
    <link rel="alternate" href="https://github.com/devsoulwolf" title="Ching.Soulwolf" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/author.png">
    
    
    <link rel="apple-touch-icon" href="/img/author.png">
    <link rel="apple-touch-icon-precomposed" href="/img/author.png">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/author.png" alt="Ching.Soulwolf" title="Ching.Soulwolf"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Ching.Soulwolf">Ching.Soulwolf</a></h1>
				<h2 class="blog-motto">Welcome to Ching.Soulwolf personal blog, and look forward to everyone&#39;s acquaintance!</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:www.cblog.cc">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/03/Android-Camera-实时滤镜/" title="Android Camera 实时滤镜" itemprop="url">Android Camera 实时滤镜</a>
  </h1>
  <p class="article-author">By
    
      <a href="https://plus.google.com/106830580871482751192?rel=author" title="Soulwolf" target="_blank" itemprop="author">Soulwolf</a>
    </p>
  <p class="article-time">
    <time datetime="2015-09-03T10:03:50.000Z" itemprop="datePublished">2015-09-03</time>
    更新日期:<time datetime="2015-09-03T12:54:35.793Z" itemprop="dateModified">2015-09-03</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Android系统将内置滤镜功能"><span class="toc-number">1.</span> <span class="toc-text">一、Android系统将内置滤镜功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Android平台滤镜"><span class="toc-number">2.</span> <span class="toc-text">二、Android平台滤镜</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="##"><span class="toc-number">3.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、相机滤镜介绍"><span class="toc-number">4.</span> <span class="toc-text">二、相机滤镜介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、图片美化滤镜"><span class="toc-number">5.</span> <span class="toc-text">三、图片美化滤镜</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、社交分享滤镜"><span class="toc-number">6.</span> <span class="toc-text">四、社交分享滤镜</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、总结"><span class="toc-number">7.</span> <span class="toc-text">五、总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、基于Android平台基本滤镜算法的实现"><span class="toc-number">8.</span> <span class="toc-text">七、基于Android平台基本滤镜算法的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、后滤镜时代"><span class="toc-number">9.</span> <span class="toc-text">八、后滤镜时代</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九，基于Android平台PS特效的自定义算法的实现"><span class="toc-number">10.</span> <span class="toc-text">九，基于Android平台PS特效的自定义算法的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_静态滤镜的实现"><span class="toc-number">11.</span> <span class="toc-text">Android 静态滤镜的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、静态滤镜的实现"><span class="toc-number">12.</span> <span class="toc-text">二、静态滤镜的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HSL色彩模式"><span class="toc-number">13.</span> <span class="toc-text">HSL色彩模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HSL色彩模式与RGB色彩模式转换代码实现"><span class="toc-number">14.</span> <span class="toc-text">HSL色彩模式与RGB色彩模式转换代码实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Camera可以做哪些？"><span class="toc-number">15.</span> <span class="toc-text">Android Camera可以做哪些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Camera_Preview是什么？"><span class="toc-number">16.</span> <span class="toc-text">Camera Preview是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何获取Camera_Preview中的数据？"><span class="toc-number">17.</span> <span class="toc-text">如何获取Camera Preview中的数据？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Camera_实时滤镜怎么做？"><span class="toc-number">18.</span> <span class="toc-text">Android Camera 实时滤镜怎么做？</span></a></li></ol>
		</div>
		
		<p>版权声明：转载自<a href="http://blog.csdn.net/wyhuan1030/article/details/45094715" title="Neil Android Camera" target="_blank" rel="external">http://blog.csdn.net/wyhuan1030/article/details/45094715</a></p>
<h1 id="一、Android系统将内置滤镜功能">一、Android系统将内置滤镜功能</h1><p>滤镜功能有二十余种不同效果，不逊色于极受欢迎的智能手机应用Instagram所产生的效果。</p>
<p><img src="http://img.blog.csdn.net/20150417112538878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>1、颜色矩阵 ColorMatrix</p>
<p>android中可以通过颜色矩阵（ColorMatrix类）方面的操作颜色，颜色矩阵是一个5x4 的矩阵。可以用来方面的修改图片中RGBA各分量的值，颜色矩阵以一维数组的方式存储如下：<br> [ a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t ]<br>他通过RGBA四个通道来直接操作对应颜色，如果会使用Photoshop就会知道有时处理图片通过控制RGBA各颜色通道来做出特殊的效果。</p>
<p>这个矩阵对颜色的作用计算方式如示：</p>
<p><img src="http://img.blog.csdn.net/20150417112506439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>矩阵的运算规则是矩阵A的一行乘以矩阵C的一列作为矩阵R的一行，</p>
<p>C矩阵是图片中包含的ARGB信息，R矩阵是用颜色矩阵应用于C之后的新的颜色分量，运算结果如下：</p>
<p>R’ = a<em>R + b</em>G + c<em>B + d</em>A + e;<br>G’ = f<em>R + g</em>G + h<em>B + i</em>A + j;<br>B’ = k<em>R + l</em>G + m<em>B + n</em>A + o;<br>A’ = p<em>R + q</em>G + r<em>B + s</em>A + t;</p>
<p>Ps：第1~3列是控制色相的，第4列是控制透明度的，第5列是分量的增加值。</p>
<p>2、基本滤镜效果的实现：</p>
<p>如果我们用ColorMatrix调整RGB三种颜色的比重，就可以实现诸如单色、黑白的效果。</p>
<p>3、Lomo滤镜效果的实现：</p>
<p>改变图像数值+遮罩</p>
<h1 id="二、Android平台滤镜">二、Android平台滤镜</h1><p>滤镜这个功能在目前的市场上应用很广泛，发展也非常快，总结起来，基本上有以下三种应用会包含滤镜功能，都各有所长。</p>
<p><img src="http://img.blog.csdn.net/20150420142811120?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h1 id="#">#</h1><h1 id="二、相机滤镜介绍">二、相机滤镜介绍</h1><p>1、相机360镜介绍</p>
<p>相机360的滤镜特效类别比较多，每一类别又分为不同的特效。</p>
<p>其最主要的特点是它具有实时拍照滤镜功能，且在关闭重新进入后可记忆之前选择的滤镜。</p>
<p>缺点是滤镜效果一般，而且选择滤镜的交互比较复杂，不好操作。</p>
<p><img src="http://img.blog.csdn.net/20150420142837750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""> <img src="http://img.blog.csdn.net/20150420142851821?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>2、魔幻时刻相机滤镜介绍（静态滤镜）</p>
<p>魔幻时刻相机Magic Hour是一款从ios移植过来的优秀拍照软件。</p>
<p>从其滤镜管理和滤镜库的丰富程度就可以看出这款相机的偏重点了！具有大量的滤镜效果且支持下载。滤镜管理页面很“整洁”，易操作。</p>
<p><img src="http://img.blog.csdn.net/20150420142747464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""> <img src="http://img.blog.csdn.net/20150420142806091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h1 id="三、图片美化滤镜">三、图片美化滤镜</h1><p>在图片美化界，美图秀秀是当之无愧的NO.1，其滤镜效果按照tab页的方式分为几类供选择，操作非常直观，且每一种特效都会有非常漂亮的效果。<br><img src="http://img.blog.csdn.net/20150420142950180?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>Pixlr-0-matic，这款图片处理工具的滤镜不管从UI设计来讲还是从交互来讲都非常赞，而且它的滤镜还有增加光影效果、色相效果等功能，美化照片能力超强。<br><img src="http://img.blog.csdn.net/20150420143004813?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h1 id="四、社交分享滤镜">四、社交分享滤镜</h1><p>社交应用也越来越注重图片分享时的滤镜功能。<br>腾讯微博的滤镜效果如图，交互简洁，清爽，滤镜效果很佳，一推出便得到广泛应用和赞扬。<br><img src="http://img.blog.csdn.net/20150420143018541?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>Path是得到普遍认可的优秀产品，包括其滤镜效果。<br>简洁是社交分享滤镜的最主要特点，path的滤镜也承袭了这一风格，且滤镜效果很佳。<br><img src="http://img.blog.csdn.net/20150420143030491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<h1 id="五、总结">五、总结</h1><p><img src="http://img.blog.csdn.net/20150420143056527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>1、采用实时拍照滤镜，在成相的同时可以使用户看到自己想要的照片效果。</p>
<p> 2、滤镜种类不宜过多，把握关键的最受用户喜欢的滤镜效果，比如：素描、油画、炫彩、老照片等经典效果。</p>
<p> 3、追求高质量滤镜效果，我们要让每一个滤镜都能够使照片变得更加漂亮，而不是鸡肋效果。</p>
<p> 4、交互上尽量简洁，一目了然，避免多重选择和切换。</p>
<h1 id="七、基于Android平台基本滤镜算法的实现">七、基于Android平台基本滤镜算法的实现</h1><p>1、Android提供了改变图像数值的方法ColorMatrix，通过ColorMatrix方法可以实现基本滤镜，如黑白、灰色、泛黄等效果。</p>
<p>2、通过ColorMatrix改变图像数值，生成变换矩阵，利用矩阵相乘，来改变每个点的像素值。</p>
<p> Matrix =&gt;</p>
<pre><code><span class="label">r1</span> <span class="literal">r2</span> <span class="literal">r3</span> <span class="literal">r4</span>
<span class="label">g1</span> g2 g3 g4
<span class="keyword">b1 </span><span class="keyword">b2 </span><span class="keyword">b3 </span><span class="keyword">b4
</span><span class="label">a1</span> <span class="literal">a2</span> <span class="literal">a3</span> <span class="literal">a4</span>
</code></pre><p>变化以后</p>
<p>R’  =  R <em> r1  +  G </em> r2  +  B <em> r3  +  A </em> r4  +  r5;</p>
<p>G’  =  R <em> g1  +  G </em> g2  +  B <em>g3  +  A </em> g4  +  g5;</p>
<p>B’  =  R <em> b1  +  G </em> b2  +  B <em>b3  +  A </em> b4  +  b5;</p>
<p>A’  =  R <em> a1  +  G </em> a2  +  B <em> a3  +  A </em> a4  +  a5;</p>
<font color="red">第1~3列是控制色相的，第4列是控制透明度的，第5列是分量的增加值</font>

<p>3、R、G、B、A系数值变化会修改图像的效果</p>
<p>（1）对角线值为1.0，其他为0时，图像保证的是原图像</p>
<p><img src="https://img.alicdn.com/imgextra/i3/1025192026/TB2nqz4eVXXXXXMXpXXXXXXXXXX_!!1025192026.png" alt=""></p>
<p><img src="http://img.blog.csdn.net/20150421092300819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>（2）对角线值若大于1.0，其他为0时，图像偏亮</p>
<p><img src="https://img.alicdn.com/imgextra/i2/1025192026/TB20ID1eVXXXXadXpXXXXXXXXXX_!!1025192026.png" alt=""></p>
<p><img src="http://img.blog.csdn.net/20150421092323704?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>（3）对角线值若小于1.0，其他为0时，图像偏暗</p>
<p><img src="https://img.alicdn.com/imgextra/i3/1025192026/TB21.f5eVXXXXXkXpXXXXXXXXXX_!!1025192026.png" alt=""></p>
<p><img src="http://img.blog.csdn.net/20150421092339335?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>（4）设定图像为灰色，通过查资料 R 0.3 G0.59 B 0.11</p>
<p><img src="https://img.alicdn.com/imgextra/i1/1025192026/TB2Epb6eVXXXXc7XXXXXXXXXXXX_!!1025192026.png" alt=""></p>
<p><img src="http://img.blog.csdn.net/20150421092512957?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>4、根据以上的实现，实现基本滤镜的算法是</p>
<p>`public Bitmap getBlackStyle(Bitmap src){</p>
<pre><code>Bitmap dst = Bitmap.createBitmap(src.getWidth(),src.getHeight(), Config.ARGB_8888);
        Canvas canvas = <span class="keyword">new</span> Canvas(dst);
        ColorMatrix cm = <span class="keyword">new</span> ColorMatrix();
        <span class="comment">//设定图像为灰色，通过查资料 R 0.3 G0.59 B 0.11</span>
        cm.<span class="built_in">set</span>(<span class="keyword">new</span> <span class="keyword">float</span>[] { 
                <span class="number">0.3f</span>, <span class="number">0.59f</span>, <span class="number">0.11f</span>, <span class="number">0</span>, <span class="number">0</span>, 
                <span class="number">0.3f</span>, <span class="number">0.59f</span>, <span class="number">0.11f</span>, <span class="number">0</span>, <span class="number">0</span>, 
                <span class="number">0.3f</span>, <span class="number">0.59f</span>, <span class="number">0.11f</span>, <span class="number">0</span>, <span class="number">0</span>, 
                <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span> });
        Paint paint = <span class="keyword">new</span> Paint();
        paint.setColorFilter(<span class="keyword">new</span> ColorMatrixColorFilter(cm));
        canvas.drawBitmap(src, <span class="number">0</span>, <span class="number">0</span>, paint);
        <span class="comment">// 保存图像</span>
        canvas.save(Canvas.ALL_SAVE_FLAG);
        <span class="comment">// 存储</span>
        canvas.restore();
        <span class="keyword">return</span> dst;
    }`
</code></pre><h1 id="八、后滤镜时代">八、后滤镜时代</h1><p>在网上看到一些信息和相机应用，很多相机玩家对手机相机的使用是越来越多，作为手机相机的开发者需要有更多的创意和特性为手机相机添彩！如下几点相机的发展方向供大家参考：</p>
<p><img src="http://img.blog.csdn.net/20150421091600117?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvV1lIdWFuMTAzMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p>
<p>（1）实时滤镜</p>
<p>VIDA 是一款来自国内团队的照相应用，它的一大特色就是实时滤镜，在拍摄的同时你已经可以<br>预览到最终的成品。这是一个强化滤镜功能的方向。和单纯的加入新滤镜不同，实时滤镜把握住了<br>所见即所得的精髓。</p>
<p>（2）GIF 动画</p>
<p>  GIFshop 是 一款快速制作定格动画的应用。它结合了动态画面的叙事能力，保留了图片的小体积特点。但 GIFshop 的问题也非常突出，比起记录生活，它更适合于创作一些幽默的动态小品。一旦涉及到 “创作” ，用户的门槛就被无情地提高了。但让画面动起来的想法要比单纯的强化滤镜要走的更远一些。</p>
<p>（3）动态图片<br> Cinemagram 制 作出来的图片可以只在某一特定区域中出现动态效果。你可以那它创建那种网<br> 上流行的“会动的海报”。比起 GIFshop ，它能够让普通的记事照片变得有点魔幻。由于应用的<br> 构思巧妙，因此适合套用在不同的场合中。用户的门槛相对较小，但收获却是挺大的。我将其看作是 GIFshop 的改进版本。</p>
<p>（4）声音+图片</p>
<p>  Picle 是 一款让你在拍摄相片的同时也记录下一段音频的应用。它的好处是让 “画外音” 这一有趣的角色参与照片的叙事。相比上述应用，Picle 进入了另个维度，它考虑到图片的叙事瓶颈，并试图通过加入音频来突破。Picle 所面临的问题是，它建立了一种新的格式，而这种格式目前还只能在 Picle 体系内分享。</p>
<p>  后滤镜时代里各支团队在不同方向上设定了不同的瓶颈，并通过一定的方法来突破。思考的起点无一例外的定在了增强图片叙事能力之上。从目前的情况来看，有一些事项值得注意：</p>
<p>· 体积：不能因为增强了效果而变得臃肿。</p>
<p>· 题材：不能因为特别适合某种题材而狭隘了用户的使用场景。</p>
<p>· 格式：在现有流行的格式上入手，避免使用新格式。</p>
<p>· 门槛：在用户利益和使用复杂度上寻求平衡。</p>
<p>· 多媒体：在图片上做加法，但不能演变成拍摄视频。</p>
<pre><code> 相信随着硬件技术的增强，手机将成为一类新的照相设备。它也许替代不了传统的相机，但
它却能因为应用而变得不可替代。而可以预见的是，滤镜不会是手机照相的最后一站。
</code></pre><h1 id="九，基于Android平台PS特效的自定义算法的实现">九，基于Android平台PS特效的自定义算法的实现</h1><p><img src="https://img.alicdn.com/imgextra/i2/1025192026/TB2RrzWeVXXXXaWXpXXXXXXXXXX_!!1025192026.png" alt=""></p>
<p>在ARGB颜色空间，分别使用A（Transparency）、R（Red）、G（Green）、B（Blue）四个值来描述一个像素点，那么对于一个宽w高h的图片来说，共有w<em>h个像素点，可以用一个数组对象int [] pixels来表示相应的图片，pixels = { p1,p2,p3…}。在把各个像素点都用ARGB来表示，那么这张图片就可以用一个[w</em>h,4]的矩阵来描述：</p>
<pre><code>pixels = {
     pa<span class="number">1</span>，pr<span class="number">1</span>，p<span class="keyword">g1</span>，pb<span class="number">1</span>，
     pa<span class="number">2</span>，pr<span class="number">2</span>，p<span class="keyword">g2</span>，pb<span class="number">2</span>，
     pa<span class="number">3</span>，pr<span class="number">3</span>，p<span class="keyword">g3</span>，pb<span class="number">3</span>，
     ……
}
</code></pre><p>android平台在获取像素方面提供了 Bitmap.getPixels 方法，我需要做的是遍历图像的像素点，对每一个像素点进行计算。然后将计算完的像素点通过Color.red/green/blue 方法处理后，将像素点填回Bitmap，从而得到滤镜后的图像。这种方式比ColorMatrix 要灵活，可以满足PS特效的实现效果。</p>
<p>1、简单的反色滤镜实现</p>
<pre><code>取出图片的像素点，然后用<span class="number">255</span>减去每个像素点，那么得到的就是一张有反色效果的图片
</code></pre><p><img src="http://img.blog.csdn.net/20150424103008605" alt=""></p>
<p>算法如下：<br>`<br>/**</p>
<ul>
<li><p>@author neil<br>*/<br>public class AntiColorFilter implements ImageFilterInterface {</p>
<p> private ImageData image = null; // 图片信息类</p>
<p> public AntiColorFilter(Bitmap bmp) {</p>
<pre><code>image = new ImageData<span class="list">(<span class="keyword">bmp</span>)</span><span class="comment">;</span>
</code></pre><p> }</p>
<p> public ImageData imageProcess() {</p>
<pre><code><span class="built_in">int</span> <span class="variable">width</span> = <span class="built_in">image</span>.getWidth();
<span class="built_in">int</span> <span class="variable">height</span> = <span class="built_in">image</span>.getHeight();
<span class="built_in">int</span> R, G, B, pixel;
<span class="keyword">for</span> (<span class="built_in">int</span> y = <span class="number">0</span>; y &lt; <span class="variable">height</span>; y++) {
    <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; <span class="variable">width</span>; x++) {
        R = <span class="built_in">image</span>.getRComponent(x, y); <span class="comment">// 获取RGB三原色</span>
        G = <span class="built_in">image</span>.getGComponent(x, y);
        B = <span class="built_in">image</span>.getBComponent(x, y);

        R = <span class="number">255</span> - R;
        B = <span class="number">255</span> - B;
        G = <span class="number">255</span> - G;

        <span class="built_in">image</span>.setPixelColor(x, y, R, G, B);
    } <span class="comment">// x</span>
} <span class="comment">// y  </span>
<span class="keyword">return</span> <span class="built_in">image</span>;
</code></pre><p> }<br>}`</p>
</li>
</ul>
<p>2、油画滤镜的实现</p>
<p>通过查资料了解到油画滤镜的算法是”用当前点四周一定范围内任意一点的颜色来替代当前点颜色，最常用的是随机的采用相邻点进行替代”</p>
<p><img src="http://img.blog.csdn.net/20150424103107223" alt=""></p>
<p>算法如下：<br>`public ImageData imageProcess() {<br>        int width = image.getWidth();<br>        int height = image.getHeight();<br>        int R, G, B, pixel,xx = 0,yy = 0;<br>        for (int y = 0; y &lt; height; y++) {<br>            for (int x = 0; x &lt; width; x++) {<br>                int pos = getRandomInt(1, 10000) % Model;<br>                xx = (x + pos) &lt; width ? (x + pos) : (x - pos) &gt;= 0 ? (x - pos) : x;<br>                yy = (y + pos) &lt; height ? (y + pos) : (y - pos) &gt;= 0 ? (y - pos) : y;  </p>
<pre><code>            R = <span class="built_in">image</span>.getRComponent(xx, yy); <span class="comment">// 获取RGB三原色</span>
            G = <span class="built_in">image</span>.getGComponent(xx, yy);
            B = <span class="built_in">image</span>.getBComponent(xx, yy);

            <span class="built_in">image</span>.setPixelColor(x, y, R, G, B);
        } <span class="comment">// x</span>
    } <span class="comment">// y</span>

    <span class="keyword">return</span> <span class="built_in">image</span>;
}

<span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> getRandomInt(<span class="built_in">int</span> a, <span class="built_in">int</span> b) {  
    <span class="built_in">int</span> <span class="built_in">min</span> = Math.<span class="built_in">min</span>(a, b);    
    <span class="built_in">int</span> <span class="built_in">max</span> = Math.<span class="built_in">max</span>(a, b);
    <span class="keyword">return</span> <span class="built_in">min</span> + (<span class="built_in">int</span>)(Math.<span class="built_in">random</span>() * (<span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>));
}`
</code></pre><p>3、冰冻滤镜的实现</p>
<p>冰冻滤镜的算法是将像素点颜色加深，每个象素都用RGB三原色来表示，（0，0，0）就是纯黑，而（255，255，255）就是纯白，因此将没个像素点的RGB指变小，颜色就会加深</p>
<p><img src="http://img.blog.csdn.net/20150424103335976" alt=""></p>
<p>`int width = image.getWidth();<br>        int height = image.getHeight();<br>        int R, G, B, pixel;<br>        for (int y = 0; y &lt; height; y++) {<br>            for (int x = 0; x &lt; width; x++) {<br>                R = image.getRComponent(x, y); // 获取RGB三原色<br>                G = image.getGComponent(x, y);<br>                B = image.getBComponent(x, y);</p>
<pre><code>        pixel = R - G - B;
        pixel = pixel * <span class="number">3</span> / <span class="number">2</span>;
        <span class="keyword">if</span> (pixel &lt; <span class="number">0</span>)
            pixel = -pixel;
        <span class="keyword">if</span> (pixel &gt; <span class="number">255</span>)
            pixel = <span class="number">255</span>;
        R = pixel; 


        pixel = G - B - R;
        pixel = pixel * <span class="number">3</span> / <span class="number">2</span>;
        <span class="keyword">if</span> (pixel &lt; <span class="number">0</span>)
            pixel = -pixel;
        <span class="keyword">if</span> (pixel &gt; <span class="number">255</span>)
            pixel = <span class="number">255</span>;
        G = pixel;


        pixel = B - R - G;
        pixel = pixel * <span class="number">3</span> / <span class="number">2</span>;
        <span class="keyword">if</span> (pixel &lt; <span class="number">0</span>)
            pixel = -pixel;
        <span class="keyword">if</span> (pixel &gt; <span class="number">255</span>)
            pixel = <span class="number">255</span>;
        B = pixel;

        image.setPixelColor(x, y, R, G, B);
    } <span class="comment">// x</span>
} <span class="comment">// y `</span>
</code></pre><h1 id="Android_静态滤镜的实现">Android 静态滤镜的实现</h1><p>一、回顾知识点</p>
<p>1、基本滤镜效果的实现（黑白滤镜）</p>
<blockquote>
<p>用到的技术是ColorMatrix。通过改变RGBA的系数，从而改变图像的成像效果。</p>
</blockquote>
<p><img src="https://img.alicdn.com/imgextra/i4/1025192026/TB2rab4eVXXXXXBXpXXXXXXXXXX_!!1025192026.png" alt=""></p>
<p>2、PS滤镜效果的实现（反色效果、冰冻效果、油画效果）</p>
<blockquote>
<p>用到的技术是通过遍历图像的像素点，设置图像的像素点的RGB三原色来实现PS效果。</p>
</blockquote>
<p><img src="https://img.alicdn.com/imgextra/i3/1025192026/TB2uIT7eVXXXXcSXXXXXXXXXXXX_!!1025192026.png" alt=""></p>
<h1 id="二、静态滤镜的实现">二、静态滤镜的实现</h1><p>基于之前积累下来的知识点，在对静态滤镜的实现方面做一下提升，还是从两方面进行实现。</p>
<p>1、基本滤镜效果升级版 –&gt; 伪lomo滤镜的实现</p>
<p><img src="https://img.alicdn.com/imgextra/i1/1025192026/TB2VaLYeVXXXXa2XpXXXXXXXXXX_!!1025192026.png" alt=""></p>
<ul>
<li><p>step1：原始图片 </p>
<p> <img src="http://img.blog.csdn.net/20150427101308194" alt=""></p>
</li>
<li><p>step2：ColorMatrix处理 </p>
<p> <img src="http://img.blog.csdn.net/20150427101352389" alt=""></p>
</li>
<li><p>step3：在处理后的图片上覆盖一层彩色lomo图片 </p>
<p> <img src="http://img.blog.csdn.net/20150427101405228" alt=""></p>
</li>
<li><p>step4：覆盖上彩色lomo后的效果 </p>
<p> <img src="http://img.blog.csdn.net/20150427101543171" alt=""></p>
</li>
<li><p>step5：伪lomo滤镜效果 </p>
<p> <img src="http://img.blog.csdn.net/20150427101656142" alt=""></p>
</li>
</ul>
<p>2、PS滤镜效果升级版 –&gt; 老照片滤镜的实现</p>
<p>（1）HSL颜色标准</p>
<ul>
<li>HSL色彩模式是工业界的一种颜色标准，是通过对色调(H)、饱和度(S)、亮度(L)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜 色的，HSL即是代表色调，饱和度，亮度三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。 　　</li>
<li>HSL色彩模式使用HSL模型为图像中每一个像素的HSL分量分配一个0~255范围内的强度值。HSL图像只使用三种通道，就可以使它们按照不同的比例混合，在屏幕上重现16777216种颜色。 　　</li>
<li>在 HSL 模式下，每种 HSL 成分都可使用从 0到 255的值。（其中L是从黑（0）到白（255）渐变） 。</li>
</ul>
<blockquote>
<p>老照片效果的总体思路是，对色调、饱和度、亮度进行处理，而非之前的红绿蓝色调处理。</p>
</blockquote>
<p>（2）算法实现</p>
<p><img src="https://img.alicdn.com/imgextra/i4/1025192026/TB2X4z9eVXXXXcNXXXXXXXXXXXX_!!1025192026.png" alt=""></p>
<ul>
<li><p>效果图 </p>
<p> <img src="http://img.blog.csdn.net/20150427103512371" alt=""></p>
</li>
</ul>
<h1 id="HSL色彩模式">HSL色彩模式</h1><hr>
<p>1、颜色HSL</p>
<pre><code>H： <span class="built_in">hue</span> 色调　　 
： <span class="built_in">saturation</span> 饱和度 　　 
L： lum 亮度
</code></pre><p>2、概述</p>
<ul>
<li>HSL色彩模式是工业界的一种颜色标准，是通过对色调(H)、饱和度(S)、亮度(L)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，HSL即是代表色调，饱和度，亮度三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。 　　</li>
<li>HSL色彩模式使用HSL模型为图像中每一个像素的HSL分量分配一个0~255范围内的强度值。HSL图像只使用三种通道，就可以使它们按照不同的比例混合，在屏幕上重现16777216种颜色。 　　</li>
<li>在 HSL 模式下，每种 HSL 成分都可使用从 0到 255的值。（其中L是从黑（0）到白（255）渐变） 。 </li>
</ul>
<p><img src="http://img.blog.csdn.net/20150428091316148" alt=""></p>
<p>3、HSL与RGB转换</p>
<p>   a. RGB→HSL的算法描述</p>
<blockquote>
<p>步骤1：把RGB值转成【0，1】中数值。 <br><br>步骤2：找出R,G和B中的最大值。 <br><br>步骤3：设L=(maxcolor + mincolor)/2 <br><br>步骤4：如果最大和最小的颜色值相同，即表示灰色，那么S定义为0，而H未定义并在程序中通常写成0。 <br><br>步骤5：否则，测试L： <br><br>　　If L<0.5, s="(maxcolor-mincolor)/(maxcolor" +="" mincolor)="" <="" br=""><br>　　If L&gt;=0.5, S=(maxcolor-mincolor)/(2.0-maxcolor-mincolor) <br><br>步骤6: If R=maxcolor, H=(G-B)/(maxcolor-mincolor) <br><br>　　If G=maxcolor, H=2.0+(B-R)/(maxcolor-mincolor) <br><br>　　If B=maxcolor, H=4.0+(R-G)/(maxcolor-mincolor) <br><br>步骤7：从第6步的计算看，H分成0～6区域。RGB颜色空间是一个立方体而HSL颜色空间是两个六角形      锥体，其中的L是RGB立方体的主对角线。因此，RGB立方体的顶点：红、黄、绿、青、蓝和品红就成为HSL六角形的顶点，而数值0～6就告诉我们H在哪个部分。H=H*60.0,如果H为负值，则加360。</0.5,></p>
</blockquote>
<p>  b. HSL→RGB的算法描述</p>
<blockquote>
<p>步骤1：If S=0,表示灰色，定义R,G和B都为L. <br><br>步骤2：否则，测试L:  <br><br>　　 If L<0.5,temp2=l*(1.0+s) <="" br=""><br>　　 If L&gt;=0.5,temp2=L+S-L<em>S  <br><br>步骤3：temp1=2.0</em>-temp2  <br><br>步骤4：把H转换到0～1。  <br><br>步骤5：对于R,G,B，计算另外的临时值temp3。方法如下： <br><br>　　 for R, temp3=H+1.0/3.0  <br><br>　　 for G, temp3=H  <br><br>　　 for B, temp3=H-1.0/3.0  <br><br>　　 if temp3<0, temp3="temp3+1.0" <="" br=""><br>　　 if temp3&gt;1, temp3=temp3-1.0  <br><br>步骤6：对于R,G,B做如下测试：  <br><br>　　 If 6.0<em>temp3&lt;1,color=temp1+(temp2-temp1)</em>6.0<em>temp3  <br><br>　　 Else if 2.0</em>temp3<1,color=temp2 <="" br=""><br>　　 Else if 3.0<em>temp3<2, <="" br=""><br>　　 color=temp1+(temp2-temp1)</2,></em>((2.0/3.0)-temp3)*6.0  <br><br>　　 Else color=temp1 <br></1,color=temp2></0,></0.5,temp2=l*(1.0+s)></p>
</blockquote>
<ul>
<li>实例 </li>
</ul>
<p><img src="http://img.blog.csdn.net/20150428091943951" alt=""><br><img src="http://img.blog.csdn.net/20150428092104196" alt=""></p>
<hr>
<h1 id="HSL色彩模式与RGB色彩模式转换代码实现">HSL色彩模式与RGB色彩模式转换代码实现</h1><pre><code><span class="built_in">RGB</span>色彩模式
</code></pre><p><img src="http://img.blog.csdn.net/20150512095634270" alt=""></p>
<pre><code>HSL色彩模式
</code></pre><p><img src="http://img.blog.csdn.net/20150512095649121" alt=""></p>
<p>HSL色彩模式与RGB色彩模式转换算法</p>
<blockquote>
<blockquote>
<p>HSL与RGB转换</p>
</blockquote>
</blockquote>
<ul>
<li><p>RGB类</p>
<p> public class ColorRGB {</p>
<p>  public int r;<br>  public int g;<br>  public int b;</p>
<p> }</p>
</li>
<li><p>HSL类</p>
<p> public class ColorHSL {</p>
<p>  public int h;<br>  public float s;<br>  public float l;</p>
<p>}</p>
</li>
</ul>
<p>a) RGB→HSL的算法描述。</p>
<blockquote>
<p>步骤1：把RGB值转成【0，1】中数值。 <br><br>步骤2：找出R,G和B中的最大值。  <br><br>步骤3：设L=(maxcolor + mincolor)/2  <br><br>步骤4：如果最大和最小的颜色值相同，即表示灰色，那么S定义为0，而H未定义并在程 序中通常写成       0。  <br><br>步骤5：否则，测试L：  <br><br>　　If L<0.5, s="(maxcolor-mincolor)/(maxcolor" +="" mincolor)="" <br=""><br>　　If L&gt;=0.5, S=(maxcolor-mincolor)/(2.0-maxcolor-mincolor)  <br><br>步骤6: If R=maxcolor, H=(G-B)/(maxcolor-mincolor)  <br><br>　　If G=maxcolor, H=2.0+(B-R)/(maxcolor-mincolor)  <br><br>　　If B=maxcolor, H=4.0+(R-G)/(maxcolor-mincolor)  <br><br>步骤7：从第6步的计算看，H分成0～6区域。RGB颜色空间是一个立方体而HSL颜色空间是两个六角形锥体，其中的L是RGB立方体的主对角线。因此，RGB立方体的顶点：红、黄、绿、青、蓝和品红就成为HSL六角形的顶点，而数值0～6就告诉我们H在哪个部分。H=H*60.0,如果H为负值，则加360。 <br></0.5,></p>
</blockquote>
<pre><code>private static ColorHSL colorRGBToHSL<span class="params">(ColorRGB rgb)</span> {

ColorHSL hsl = new ColorHSL<span class="params">()</span>;

float r, g, b, h, s, l;
r = rgb.r / <span class="number">255.0</span>f;
g = rgb.g / <span class="number">255.0</span>f;
b = rgb.b / <span class="number">255.0</span>f;

float maxColor = Math.<span class="built_in">max</span><span class="params">(r, Math.max<span class="params">(g, b)</span>)</span>;
float minColor = Math.<span class="built_in">min</span><span class="params">(r, Math.min<span class="params">(g, b)</span>)</span>;

<span class="keyword">if</span> <span class="params">(maxColor == minColor)</span> {
    h = <span class="number">0.0</span>f;
    s = <span class="number">0.0</span>f;
    l = r;
} <span class="keyword">else</span> {
    l = <span class="params">(minColor + maxColor)</span> / <span class="number">2</span>;

    <span class="keyword">if</span> <span class="params">(l &lt; <span class="number">0.5</span>)</span>
        s = <span class="params">(maxColor - minColor)</span> / <span class="params">(maxColor + minColor)</span>;
    <span class="keyword">else</span>
        s = <span class="params">(float)</span> <span class="params">(<span class="params">(maxColor - minColor)</span> / <span class="params">(<span class="number">2.0</span> - maxColor - 
             minColor)</span>)</span>;

    <span class="keyword">if</span> <span class="params">(r == maxColor)</span>
        h = <span class="params">(g - b)</span> / <span class="params">(maxColor - minColor)</span>;
    <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(g == maxColor)</span>
        h = <span class="params">(float)</span> <span class="params">(<span class="number">2.0</span> + <span class="params">(b - r)</span> / <span class="params">(maxColor - minColor)</span>)</span>;
    <span class="keyword">else</span>
        h = <span class="params">(float)</span> <span class="params">(<span class="number">4.0</span> + <span class="params">(r - g)</span> / <span class="params">(maxColor - minColor)</span>)</span>;

    h /= <span class="number">6</span>;
    <span class="keyword">if</span> <span class="params">(h &lt; <span class="number">0</span>)</span>
        h++;
}

hsl.h = <span class="params">(int)</span> Math.<span class="built_in">round</span><span class="params">(h * <span class="number">360.0</span>)</span>;
hsl.s = s;
hsl.l = l;

return hsl;
}
</code></pre><p>b) HSL→RGB的算法描述</p>
<blockquote>
<p>步骤1：If S=0,表示灰色，定义R,G和B都为L. <br><br>步骤2：否则，测试L:  <br><br>　　 If L<0.5,temp2=l*(1.0+s) <br=""><br>　　 If L&gt;=0.5,temp2=L+S-L<em>S  <br><br>步骤3：temp1=2.0</em>-temp2  <br><br>步骤4：把H转换到0～1。  <br><br>步骤5：对于R,G,B，计算另外的临时值temp3。方法如下：  <br><br>　　 for R, temp3=H+1.0/3.0  <br><br>　　 for G, temp3=H  <br><br>　　 for B, temp3=H-1.0/3.0  <br><br>　　 if temp3<0, temp3="temp3+1.0" <br=""><br>　　 if temp3&gt;1, temp3=temp3-1.0  <br><br>步骤6：对于R,G,B做如下测试：  <br><br>　　 If 6.0<em>temp3&lt;1,color=temp1+(temp2-temp1)</em>6.0<em>temp3  <br><br>　　 Else if 2.0</em>temp3<1,color=temp2 <br=""><br>　　 Else if 3.0<em>temp3<2, <br=""><br>　　 color=temp1+(temp2-temp1)</2,></em>((2.0/3.0)-temp3)*6.0  <br><br>　　 Else color=temp1 <br></1,color=temp2></0,></0.5,temp2=l*(1.0+s)></p>
</blockquote>
<pre><code><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ColorRGB <span class="title">colorHSLToRGB</span><span class="params">(ColorHSL hsl)</span> </span>{

ColorRGB rgb = <span class="keyword">new</span> ColorRGB();

<span class="keyword">float</span> r, g, b, h, s, l;
<span class="keyword">float</span> temp1, temp2, tempr, tempg, tempb;
h = hsl.h / <span class="number">360.0f</span>;
s = hsl.s;
l = hsl.l;


<span class="keyword">if</span> (s == <span class="number">0</span>) {
    r = g = b = l;
} <span class="keyword">else</span> {
    <span class="keyword">if</span> (l &lt; <span class="number">0.5</span>)
        temp2 = l * (<span class="number">1</span> + s);
    <span class="keyword">else</span>
        temp2 = (l + s) - (l * s);
    temp1 = <span class="number">2</span> * l - temp2;
    tempr = (<span class="keyword">float</span>) (h + <span class="number">1.0</span> / <span class="number">3.0</span>);
    <span class="keyword">if</span> (tempr &gt; <span class="number">1</span>)
        tempr--;
    tempg = h;
    tempb = (<span class="keyword">float</span>) (h - <span class="number">1.0</span> / <span class="number">3.0</span>);
    <span class="keyword">if</span> (tempb &lt; <span class="number">0</span>)
        tempb++;

    <span class="comment">// Red</span>
    <span class="keyword">if</span> (tempr &lt; <span class="number">1.0</span> / <span class="number">6.0</span>)
        r = (<span class="keyword">float</span>) (temp1 + (temp2 - temp1) * <span class="number">6.0</span> * tempr);
    <span class="keyword">else</span> <span class="keyword">if</span> (tempr &lt; <span class="number">0.5</span>)
        r = temp2;
    <span class="keyword">else</span> <span class="keyword">if</span> (tempr &lt; <span class="number">2.0</span> / <span class="number">3.0</span>)
        r = (<span class="keyword">float</span>) (temp1 + (temp2 - temp1) * ((<span class="number">2.0</span> / <span class="number">3.0</span>) - tempr)
                    * <span class="number">6.0</span>);
    <span class="keyword">else</span>
        r = temp1;

    <span class="comment">// Green</span>
    <span class="keyword">if</span> (tempg &lt; <span class="number">1.0</span> / <span class="number">6.0</span>)
        g = (<span class="keyword">float</span>) (temp1 + (temp2 - temp1) * <span class="number">6.0</span> * tempg);
    <span class="keyword">else</span> <span class="keyword">if</span> (tempg &lt; <span class="number">0.5</span>)
        g = temp2;
    <span class="keyword">else</span> <span class="keyword">if</span> (tempg &lt; <span class="number">2.0</span> / <span class="number">3.0</span>)
        g = (<span class="keyword">float</span>) (temp1 + (temp2 - temp1) * ((<span class="number">2.0</span> / <span class="number">3.0</span>) - tempg)
                    * <span class="number">6.0</span>);
    <span class="keyword">else</span>
        g = temp1;

    <span class="comment">// Blue</span>
    <span class="keyword">if</span> (tempb &lt; <span class="number">1.0</span> / <span class="number">6.0</span>)
        b = (<span class="keyword">float</span>) (temp1 + (temp2 - temp1) * <span class="number">6.0</span> * tempb);
    <span class="keyword">else</span> <span class="keyword">if</span> (tempb &lt; <span class="number">0.5</span>)
        b = temp2;
    <span class="keyword">else</span> <span class="keyword">if</span> (tempb &lt; <span class="number">2.0</span> / <span class="number">3.0</span>)
        b = (<span class="keyword">float</span>) (temp1 + (temp2 - temp1) * ((<span class="number">2.0</span> / <span class="number">3.0</span>) - tempb)
                    * <span class="number">6.0</span>);
    <span class="keyword">else</span>
        b = temp1;
}

rgb.r = (<span class="keyword">int</span>) Math.round(r * <span class="number">255.0</span>);
rgb.g = (<span class="keyword">int</span>) Math.round(g * <span class="number">255.0</span>);
rgb.b = (<span class="keyword">int</span>) Math.round(b * <span class="number">255.0</span>);

<span class="keyword">return</span> rgb;
}
</code></pre><hr>
<h1 id="Android_Camera可以做哪些？">Android Camera可以做哪些？</h1><p>1、功能</p>
<ul>
<li>拍摄相片</li>
<li>视频录制</li>
<li>取景器(扫描类应用，如人脸识别，名片识别，条形码识别)</li>
</ul>
<p>2、根据Camera API实现自己的拍照程序，共7步</p>
<p><img src="https://img.alicdn.com/imgextra/i2/1025192026/TB20JLReVXXXXcPXpXXXXXXXXXX_!!1025192026.png" alt=""></p>
<h1 id="Camera_Preview是什么？">Camera Preview是什么？</h1><p><img src="http://img.blog.csdn.net/20150520174146432" alt=""></p>
<p>摄像头返回的RAW数据经过isp处理后形成yuv数据，android系统将该数据绘制到取景区上，不断绘制帧数据形成实时预览数据。</p>
<h1 id="如何获取Camera_Preview中的数据？">如何获取Camera Preview中的数据？</h1><ul>
<li>Camera.PreviewCallback</li>
<li>setPreviewCallback <br><br>屏幕上显示一个新的预览帧时调用onPreviewFrame方法（时时获取）</li>
<li>setPreviewCallbackWithBuffer <br><br>其与setPreviewCallback的工作方式相同，但要求指定一个字节数 <br><br>组作为缓冲区，用于预览图像数据（addCallbackBuffer）</li>
</ul>
<h1 id="Android_Camera_实时滤镜怎么做？">Android Camera 实时滤镜怎么做？</h1><p><img src="https://img.alicdn.com/imgextra/i2/1025192026/TB2rs23eVXXXXacXpXXXXXXXXXX_!!1025192026.png" alt=""></p>
<blockquote>
<p>YUV转RGB的算法，转换的公式一般如下，也是线性的关系： <br><br>R = Y + 1.14V  <br><br>G = Y - 0.39U - 0.58V  <br><br>B = Y + 2.03U <br></p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150520175251648" alt=""></p>
<blockquote>
<p>问题 <br><br>1、屏幕卡顿，用户体验低  <br><br>2、性能低，影响系统性能 <br><br> <br><br>如何优化？  <br></p>
<ul>
<li>提高流程度  <br><br>图像渲染采用OpenGL ES SurfaceTexture  <br></li>
<li>提高性能  <br><br>GPU优化 <br></li>
</ul>
</blockquote>
  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Camera/">Camera</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://www.cblog.cc/2015/09/03/Android-Camera-实时滤镜/" data-title="Android Camera 实时滤镜 | Ching.Soulwolf" data-tsina="null" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 

<div class="next">
<a href="/2015/09/03/New-environment-new-start/"  title="New environment,new start">
 <strong>NEXT:</strong><br/> 
 <span>New environment,new start
</span>
</a>
</div>

</nav>

	
<section class="comment">
	<div class="ds-thread"></div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Android系统将内置滤镜功能"><span class="toc-number">1.</span> <span class="toc-text">一、Android系统将内置滤镜功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Android平台滤镜"><span class="toc-number">2.</span> <span class="toc-text">二、Android平台滤镜</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="##"><span class="toc-number">3.</span> <span class="toc-text">#</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、相机滤镜介绍"><span class="toc-number">4.</span> <span class="toc-text">二、相机滤镜介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、图片美化滤镜"><span class="toc-number">5.</span> <span class="toc-text">三、图片美化滤镜</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、社交分享滤镜"><span class="toc-number">6.</span> <span class="toc-text">四、社交分享滤镜</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、总结"><span class="toc-number">7.</span> <span class="toc-text">五、总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#七、基于Android平台基本滤镜算法的实现"><span class="toc-number">8.</span> <span class="toc-text">七、基于Android平台基本滤镜算法的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#八、后滤镜时代"><span class="toc-number">9.</span> <span class="toc-text">八、后滤镜时代</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#九，基于Android平台PS特效的自定义算法的实现"><span class="toc-number">10.</span> <span class="toc-text">九，基于Android平台PS特效的自定义算法的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_静态滤镜的实现"><span class="toc-number">11.</span> <span class="toc-text">Android 静态滤镜的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、静态滤镜的实现"><span class="toc-number">12.</span> <span class="toc-text">二、静态滤镜的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HSL色彩模式"><span class="toc-number">13.</span> <span class="toc-text">HSL色彩模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HSL色彩模式与RGB色彩模式转换代码实现"><span class="toc-number">14.</span> <span class="toc-text">HSL色彩模式与RGB色彩模式转换代码实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Camera可以做哪些？"><span class="toc-number">15.</span> <span class="toc-text">Android Camera可以做哪些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Camera_Preview是什么？"><span class="toc-number">16.</span> <span class="toc-text">Camera Preview是什么？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#如何获取Camera_Preview中的数据？"><span class="toc-number">17.</span> <span class="toc-text">如何获取Camera Preview中的数据？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Android_Camera_实时滤镜怎么做？"><span class="toc-number">18.</span> <span class="toc-text">Android Camera 实时滤镜怎么做？</span></a></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			<li><a href="/tags/Camera/" title="Camera">Camera<sup>1</sup></a></li>
		
			<li><a href="/tags/过去，现在，未来/" title="过去，现在，未来">过去，现在，未来<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="https://github.com/devsoulwolf" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Don&#39;t aim for success if you want it; just do what you love and believe in, and it will come naturally. <br/>
			如果你想要成功，不要去追求成功；尽管做你自己热爱的事情并且相信它，成功自然到来。</p>
	</section>
	 
	<div class="social-font clearfix">
		
		<a href="http://weibo.com/freakqin" target="_blank" title="weibo"></a>
		
		
		<a href="https://twitter.com/devsoulwolf" target="_blank" title="twitter"></a>
		
		
		<a href="https://github.com/devsoulwolf" target="_blank" title="github"></a>
		
		
		<a href="https://www.facebook.com/soulwolf.ching" target="_blank" title="facebook"></a>
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2015 
		
		<a href="http://www.cblog.cc" target="_blank" title="Soulwolf">Soulwolf</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>


<script type="text/javascript">
  var duoshuoQuery = {short_name:"soulwolf"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 





  </body>
</html>
